{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Git","text":""},{"location":"#git_1","title":"git","text":"<p>git es el gestor de versiones de software m\u00e1s popular de la actualidad.  Utiliza repositorios donde se registran todos los cambios sobre todos los archivos de c\u00f3digo a proteger y versionar.</p> <p>Comenzar con git</p>"},{"location":"tags/","title":"Tags","text":"<p>Todas las etiquetas del documento aparecen aqu\u00ed.</p>"},{"location":"tags/#tag:bash","title":"Bash","text":"<ul> <li>            Agregado y guardado          </li> <li>            Archivo de excepciones          </li> <li>            Cambios y registro          </li> <li>            Comandos Bash          </li> <li>            Comandos bash          </li> </ul>"},{"location":"tags/#tag:git","title":"Git","text":"<ul> <li>            Agregado y guardado          </li> <li>            Alias y Comandos personalizados          </li> <li>            Archivo de excepciones          </li> <li>            Bifurcaciones          </li> <li>            Cambios y registro          </li> <li>            Comando checkout          </li> <li>            Comandos Bash          </li> <li>            Comandos bash          </li> <li>            Commits previos          </li> <li>            Configuracion inicial          </li> <li>            Enlaces          </li> <li>            Etiquetado          </li> <li>            Forks en GitHub          </li> <li>            Guardado provisorio          </li> <li>            Introducci\u00f3n          </li> <li>            Repositorios remotos          </li> <li>            Taller Midudev          </li> </ul>"},{"location":"tags/#tag:github","title":"GitHub","text":"<ul> <li>            Alias y Comandos personalizados          </li> <li>            GitHub Pages          </li> <li>            Taller Midudev          </li> </ul>"},{"location":"borradores/comandos_bash/","title":"Comandos bash","text":"<pre><code>git branch etiquetador\ngit switch etiquetador\ngit push -u  origin etiquetador     # sincronizar con rama remota\ngit push -u  v1.0.0                 # etiqueta remota\n\n\ngit push origin v0.6.0  # tag remoto\n\ngit push --set-upstream origin numba  # crear rama remota y sincronizar\n\n\ngit remote add origin &lt;ruta_repositorio&gt;\n# git remote add origin https://GitHub.com/alejrot/Reflex-TutorialMouredev.git\ngit push --set-upstream origin master # \n</code></pre>","tags":["Git","Bash"]},{"location":"borradores/enlaces/","title":"Enlaces","text":"<p>Hola Mundo </p> <p>Curso de GIT y GITHUB desde CERO para PRINCIPIANTES - Brais Moure</p> <p>https://www.freecodecamp.org/espanol/news/como-borrar-una-branch-de-git-en-ambos-repositorios-local-y-remoto/#:~:text=Borrar%20una%20branch%20LOCAL&amp;text=Borra%20una%20branch%20local%20con%20git%20branch%20-d%20.&amp;text=La%20opci\u00f3n%20-d%20eliminar\u00e1%20la,sido%20empujada%20o%20fusionada%20a\u00fan.</p> <p>https://komodor.com/learn/how-to-fix-fatal-remote-origin-already-exists-error/</p> <p>https://desarrolloweb.com/articulos/descartar-cambios-archivos-git.html</p> <p>https://keepcoding.io/blog/como-deshacer-y-rehacer-cambios-en-git/#:~:text=Si%20requieres%20regresar%20a%20alguna,%2C%20\u2013mixed%20y%20\u2013soft.</p> <p>https://www.lachicainformatica.com/2020/06/git-volver-a-commit-anterior-viajes-en-el-tiempo.html</p>","tags":["Git"]},{"location":"borradores/forkear/","title":"Forks en GitHub","text":"","tags":["Git"]},{"location":"borradores/forkear/#actualizar-fork-local","title":"actualizar fork local","text":"<p>https://styde.net/actualizar-el-fork-de-un-repositorio-de-github/</p> <pre><code># Agregar la referencia al repositorio remoto original, al cual llamaremos \u00abupstream\u00bb, esto lo logramos con:\ngit remote add upstream https://github.com/whoever/whatever.git\n# Traernos todas las ramas de dicho repositorio remoto con:\ngit fetch upstream\n# Irnos a la rama que queremos actualizar, por ejemplo master: \ngit checkout master\n# Reescribir nuestra rama master con los commits nuevos de la rama master del repositorio original con:\ngit rebase upstream/master\n# Finalmente si queremos actualizar nuestro fork remoto, lo haremos ejecutando \ngit push -f origin master\n</code></pre>","tags":["Git"]},{"location":"borradores/forkear/#actualizar-fork-desde-pagina-de-github","title":"actualizar fork desde pagina de github","text":"<p>https://victorhckinthefreeworld.com/2021/01/21/actualizar-un-fork-de-un-repositorio-git-desde-la-interfaz-web-de-github/</p> <p>https://docs.github.com/es/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork?platform=windows</p> <p>https://victorhckinthefreeworld.com/2021/01/21/actualizar-un-fork-de-un-repositorio-git-desde-la-interfaz-web-de-github/</p>","tags":["Git"]},{"location":"borradores/forkear/#sincronizar","title":"Sincronizar","text":"<p>https://www.freecodecamp.org/espanol/news/como-sincronizar-tu-fork-con-el-repositorio-original-de-git/</p>","tags":["Git"]},{"location":"borradores/forkear/#configurar","title":"Configurar","text":"<pre><code># Agregar un nuevo repositorio upstream remoto\ngit remote add upstream https://github.com/PROPIETARIO_ORIGINAL/REPOSITORIO_ORIGINAL.git\n\n# Sincroniza tu Fork\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\n</code></pre> <pre><code># solo indicar\u00e1 'origin' (nuestro fork)\ngit remote -v\n</code></pre> <pre><code># agregar 'upstream' (fuente original) \ngit remote add upstream https://github.com/PROPIETARIO_ORIGINAL/REPOSITORIO_ORIGINAL.git\n</code></pre> <pre><code># ahora indicar\u00e1 'origin' y 'upstream'\ngit remote -v\n</code></pre>","tags":["Git"]},{"location":"borradores/forkear/#actualizar","title":"Actualizar","text":"<pre><code># ir a rama principal\ngit checkout master\n# Switched to branch 'master'\n</code></pre> <pre><code># detectar cambios\ngit fetch upstream\n</code></pre> <pre><code># traer cambios\ngit merge upstream/master\n</code></pre>","tags":["Git"]},{"location":"borradores/forkear/#pull-requests-en-github","title":"Pull Requests en GitHub","text":"<p>https://docs.github.com/es/pull-requests</p> <p>https://www.freecodecamp.org/espanol/news/como-crear-tu-primer-pull-request-en-github/</p>","tags":["Git"]},{"location":"borradores/gh_pages/","title":"GitHub Pages","text":"<p>https://pages.github.com</p> <p>GitHub permite crear un sitio web con subdominio de Github en base a los archivos MD de cada repositorio.</p> <p>https://docs.github.com/es/pages</p>","tags":["GitHub"]},{"location":"borradores/git/","title":"GIT","text":""},{"location":"borradores/git/#generar-token","title":"Generar token","text":"<p>El servidor nos pedir\u00e1 un usuario y contrase\u00f1a.En github esta \u00faltima se obtiene as\u00ed:</p> <ul> <li>Pesta\u00f1a Settings \u2192 Developer Settings \u2192 Personal Access Tokens \u2192 Generate New Token ; </li> <li>Creamos un nombre para el token e indicamos sus permisos; </li> <li>Finalizamos clickeando Generate Token, esto crea el token y una contrase\u00f1a al final. Clickeando en ella se copia al portapapeles y luego se pega en la terminal de trabajo.</li> </ul>"},{"location":"borradores/git/#restaurar-archivos","title":"Restaurar Archivos","text":"<pre><code>git restore &lt;archivo&gt;  # descarta cambios respecto del \u00faltimo estado guardado ('add' o 'commit') \n</code></pre> <p>Para descartar tambi\u00e9n los cambios preguardados sobre el archivo y volver a su ultimo 'commit': <pre><code># MAL: si el archivo fue 'added' no vuelve al commit\n\ngit restore --staged &lt;archivo&gt;   # descarta el 'add' y sus cambios\ngit restore &lt;archivo&gt;  # descarta cambios respecto del \u00faltimo estado guardado ('add' o 'commit') \n</code></pre> Otra opci\u00f3n: <pre><code>git reset HEAD &lt;archivo&gt;  # MAL\n</code></pre> Para restaurar todos los archivos al \u00faltimo 'commit' realizado: <pre><code>git reset --hard\n</code></pre> Otra opci\u00f3n es usar el comando revert: <pre><code>git revert &lt;id&gt;\n</code></pre></p>"},{"location":"borradores/git/#git-flow","title":"Git Flow","text":"<p>Incluye un manejo simpificado de ramas prededefinidas ,con los siguientes roles: - main: es la rama de producci\u00f3n , la rama del proyecto m\u00e1s testeada y confiable. - develop: la rama de desarrollo, que es una bifurcaci\u00f3n de main y a partir de ella se hacen los cambios del proyecto. Los merges se llevan a la rama main. - feature: son una bifurcaci\u00f3n de bifurcaciones de la rama develop dedicadas a desarrrollar caracteristicas espec\u00edficas. De esta rama puede haber varias. - hotfix: son bifurcaciones de la rama main para arreglos de emergencia y afecta al resto de las rama autom\u00e1ticamente.</p>"},{"location":"borradores/git/#git-cherry-pick","title":"Git Cherry-Pick","text":"<p>Permite traer a la rama actual commits particulares: <pre><code>git cherry-pick &lt;nombre_commit&gt;\n</code></pre> Para traer los commits posteriores al elegido uno por uno se usa la posici\u00f3n 'continue': <pre><code>git cherry-pick --continue\n</code></pre> Es un comando riesgoso porque puede traer conflictos.</p>"},{"location":"borradores/git/#git-rebase","title":"Git Rebase","text":"<p>Se trae al presente una rama antigua seleccionada. Es un comando riesgoso. <pre><code>git rebase &lt;nombre_rama&gt;\n</code></pre> otras opciones:</p> <pre><code>git rebase -i\ngit rebase --continue\ngit rebase --abort\n</code></pre>"},{"location":"borradores/git/#colaboradores-remotos-en-git","title":"Colaboradores Remotos en GIT","text":"<p>https://desarrolloweb.com/articulos/git-clone-clonar-repositorio.html</p> <p>https://git-scm.com/book/es/v2/Fundamentos-de-Git-Trabajar-con-Remotos</p>"},{"location":"extra/checkout/","title":"Comando <code>checkout</code>","text":"<p>El comando <code>checkout</code> sirve para manejar ramas y cambiar el <code>HEAD</code> de ubicaci\u00f3n. Este comando actualmente es evitado en favor de sus comandos sustitutos,  los cuales son <code>branch</code>,  <code>switch</code>  y </p>","tags":["Git"]},{"location":"extra/checkout/#ramas","title":"Ramas","text":"","tags":["Git"]},{"location":"extra/checkout/#crear","title":"Crear","text":"<p>Crear una nueva rama con el nombre indicado y pasa a la misma: <pre><code>git checkout -b  nombre_nueva_rama\n</code></pre> en este caso git nos pasa a la nueva rama automaticamente.</p>","tags":["Git"]},{"location":"extra/checkout/#cambiar","title":"Cambiar","text":"<p>Cambiar de rama <pre><code>git checkout  nombre_rama\n</code></pre></p> <p>Es preferible el comando 'switch' porque es m\u00e1s respetuoso del contenido que 'checkout' </p>","tags":["Git"]},{"location":"extra/checkout/#restaurar-archivos","title":"Restaurar Archivos","text":"<p>Para deshacer los cambios hechos sobre un archivo preguardado con el comando <code>add</code>: <pre><code>git checkout -- nombre_archivo  #deshace cambios no 'added'\n</code></pre></p>","tags":["Git"]},{"location":"extra/comandos/","title":"Comandos de Bash","text":"<p>Para manejar git es conveniente manejar algunos comandos b\u00e1sicos de la terminal.</p> <p>La terminal m\u00e1s popular es Bash, cuyo comandos m\u00e1s b\u00e1sicos se enumeran a continuaci\u00f3n.</p>","tags":["Git","Bash"]},{"location":"extra/comandos/#explorar","title":"Explorar","text":"<p>Los archivos del actual directorio (carpeta) se consultan con el comando <code>ls</code>:</p> Listar archivos - s\u00f3lo visibles<pre><code>ls\n</code></pre> Listar archivos - todos<pre><code>ls -a\n</code></pre>","tags":["Git","Bash"]},{"location":"extra/comandos/#navegar","title":"Navegar","text":"<p>Consultar directorio actual  <pre><code>pwd\n</code></pre> Entrar a un sub directorio: <pre><code>cd nombre_carpeta\n</code></pre></p> <p>HINT: autocompletado de nombres</p> <p>Escribir el nombre de archivos y carpetas parcialmente y entonces presionar TAB para autocompletar.</p> <p>Retroceder al directorio superior: <pre><code>cd ..\n</code></pre></p> <p>Entrar a una carpeta espec\u00edfica existente: <pre><code>cd \u2018ruta_de_carpeta\u2019\n</code></pre></p>","tags":["Git","Bash"]},{"location":"extra/comandos/#manejo-de-directorios","title":"Manejo de directorios","text":"<p>Las carpetas se gestionan con los comandos <code>mkdir</code> y <code>rmdir</code>:</p> Crear directorio<pre><code>mkdir nombre_carpeta\n</code></pre> Borrar directorio - s\u00f3lo vac\u00edos<pre><code>rmdir nombre_carpeta\n</code></pre>","tags":["Git","Bash"]},{"location":"extra/comandos/#mover-y-renombrar","title":"Mover y renombrar","text":"<p>Tanto los archivos como las carpetas se reubican con el nombre <code>mv</code>:</p> Mover archivo<pre><code>mv  nombre_archivo  nombre_carpeta/\n</code></pre> Renombrar archivo<pre><code>mv  nombre_archivo  nuevo_nombre_archivo\n</code></pre>","tags":["Git","Bash"]},{"location":"extra/comandos/#manejo-de-archivos","title":"Manejo de archivos","text":"<p>Los archivos de texto se leen desde terminal con el comando <code>cat</code>:</p> Leer archivo<pre><code>cat nombre_archivo\n</code></pre> <p>en tanto que pueden ser editados desde terminal con editores b\u00e1sicos como <code>nano</code> o <code>vim</code>:</p> Editar archivo - nano<pre><code>nano nombre_archivo\n</code></pre> Editar archivo - vim<pre><code>vim nombre_archivo\n</code></pre> <p>Con <code>touch</code> se crea desde terminal un archivo vac\u00edo con el nombre indicado:</p> Crear archivo vacio<pre><code>touch nombre_archivo\n</code></pre> <p>en tanto que para eliminarlo se usa <code>rm</code>:</p> Eliminar archivo<pre><code>rm nombre_archivo\n</code></pre> <p><code>rm</code> tambi\u00e9n permite eliminar carpetas con contenido interno:</p> Eliminar directorio<pre><code>rm -r nombre_carpeta\n</code></pre>","tags":["Git","Bash"]},{"location":"extra/comandos/#editores-de-codigo","title":"Editores de c\u00f3digo","text":"<p>Los IDE's tambi\u00e9n pueden ser llamados desde la shell para leer y editar archivos:</p> IDE - Editar archivo<pre><code>nombre_editor  nombre_archivo\n</code></pre> <p>aunque esta es una opci\u00f3n muy inc\u00f3moda debido a que los IDE's habitualmente tienen una apertura lenta.</p> <p>Ejemplos: </p> VSCodeVSCodium VSCode - Editar archivo<pre><code>code   nombre_archivo\n</code></pre> VSCodium - Editar archivo<pre><code>codium nombre_archivo\n</code></pre> <p>TIP: abrir directorio como workspace</p> <p>Se puede abrir el programa de edici\u00f3n elegido en el directorio actual  desde la terminal:</p> <p>IDE - Cargar directorio<pre><code>nombre_editor  nombre_archivo\n</code></pre> Por ejemplo, para abrir VSCodium desde terminal con el directorio del proyecto actual precargado como workspace:</p> VSCodeVSCodium VSCode   - Cargar workspace<pre><code>code   .\n</code></pre> VSCodium - Cargar workspace<pre><code>codium .\n</code></pre>","tags":["Git","Bash"]},{"location":"extra/taller_midu/","title":"Taller Miududev - Git para aportar a proyectos","text":"<p>INFO: SCM: Source Code Management</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#buscar-proyectos-para-contribuir","title":"Buscar proyectos para contribuir","text":"<p>For Good First Issue</p> <p>Proyectos abiertos a contribuciones, con impacto en ONGs, gobiernos, etc.</p> <p>Good First Issue</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#tip-buscar-archivos-contributing","title":"Tip: buscar archivos 'Contributing'","text":"<p>Es una buena idea buscar los requisitos para contribuciones de proyectos ya establecidos para conocer buenas practicas, ver requisitos, etc .</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#clonar-proyectos","title":"Clonar proyectos","text":"<p>Tres opciones:  - HTTP: no recomendada, pues se pide usuario y contrase\u00f1a - SSH: requiere clave SSH (configuracion previa dependiente del sistema opeerativo) - GitHub CLI</p> <p>Clonado (completo):</p> <pre><code>git clone http:ruta_repo        # HTTP\ngit clone git@ruta_repo         # SSH\ngh repo clone user/repo         # GitHub CLI\n</code></pre> <p>Clonado - s\u00f3lo \u00faltimo commit (suele ahorrar MUCHO espacio en disco) - opcion <code>--depth=1</code>:</p> <pre><code>git clone ruta_repo  --depth=1\n</code></pre>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#modificar","title":"Modificar","text":"<pre><code>git status\ngit add archivo\n</code></pre> <p>Commit:</p> <pre><code>git commit --message \"mensaje del commmit\"\n</code></pre> <p>MAL: el repositorio online NO es nuestro</p> <pre><code>git push -u origin main\n</code></pre>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#forks","title":"Forks","text":"<p>El fork es la copia del proyecto original a propiedad del nuevo usuario.</p> <p>El fork puede ser completo o puede abarcar una sola rama original.</p> <p>Para trabajar se clona el repositorioi fork en vez de clonar el original.</p> <pre><code>git remote --verbose\n</code></pre> <p>Info:     origin --&gt; nuestro repositorio     upstream --&gt; repositorio original</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#crear-nueva-rama","title":"Crear nueva rama","text":"<pre><code>git switch -c nombre_nueva_rama\n</code></pre> <p>TIP Hacer cambios en rama dedicada</p> <pre><code>Es mejor EVITAR retocar la rama principal de nuestro fork para poder actualizarla f\u00e1cilmente cuando el proyecto fuente haga cambios.\n</code></pre> <p>INFO:  \"git checkout\" deprecated Los creadores de git ya NO recomiendan usar el comando checkout por ser multiuso, sirviendo tanto para cambiar de ramas como para restaurar ramas y archivos. Comandos sustitutos: switch y restore</p> <p>TIP: \"ser quir\u00fargico\" Para proponer cambios al proyecto original es mejor hacer los m\u00ednimos cambios necesarios para cumplir el objetivo. Evitar la tentaci\u00f3n de hacer cambios de estilo, renombrar archivos, etc.</p> <p>TIP: evitar signos de puntuaci\u00f3n en los commits (Titulo: maximo:72 caracteres, recomendado 50 caracteres) (descripcion: recomendado 72 caracteres)</p> <p>TIP commits con titulo y descripci\u00f3n</p> <pre><code>git commit -m \"Title\" -m \"Description....\"\n\n\nhttps://stackoverflow.com/questions/16122234/how-to-commit-a-change-with-both-message-and-description-from-the-command-li\n</code></pre> <p>INFO:  Commit: \"Confirmar cambios\"</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#pull-request","title":"Pull request","text":"<p>En el pedido de cambios se indica tanto el origen (repositorio fork y rama de los cambios) y el destino (repositorio origen y rama, t\u00edpicamente la principal).</p> <p>En GitHub se pueden adjuntar capturas de pantallas , videos, etc. Sin embargo es conveniente hacer las pull requests lo m\u00e1s concisas y explicativas que sea posible</p> <p>Dos opciones: \"Draft pull request\" (pedido borrador, no se puede aceptar hasta completar cambios) y \"Create puyll request\" (pedido definitivo).</p>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#github-flow","title":"GitHub Flow","text":"<p>Los pasos previos siguen la gu\u00eda del GitHub Flow: una rama de desarrollo que implementa pocos cambios y se une a la rama principal del proyecto.</p> <p>Las ramas ya \"mergeadas\" por los administradores del proyecto pueden eliminarse. Para recuperar el trabajo hecho o simplemente traer nuevos cambios de terceros al fork hay que sincronizar. Para hacerlo desde consola:</p> <pre><code>git pull upstream main      # descarga de cambios desde proyecto original (a local)\ngit push origin main        # subida a nuestro repositorio (remoto)\n</code></pre> <p>Traer ramas desde repositorio remoto</p> <pre><code>git fetch\n</code></pre>","tags":["Git","GitHub"]},{"location":"extra/taller_midu/#agregar-repositorio-remoto","title":"Agregar repositorio remoto","text":"<p>Un mismo repositorio puede apuntar a m\u00faltiples repositorios remotos</p> <pre><code>git remote add alias_remoto ruta_remoto\n</code></pre>","tags":["Git","GitHub"]},{"location":"git/alias_comandos/","title":"Alias y Comandos personalizados","text":"","tags":["Git","GitHub"]},{"location":"git/alias_comandos/#alias-de-comandos-git","title":"Alias de comandos Git","text":"<p>Se pueden crear alias para los comandos m\u00e1s usados <pre><code>git config --global alias.apodo   comandos\n</code></pre></p> <p>A continuaci\u00f3n se proponen algunos ejemplos de alias \u00fatiles.</p> <p>Comando unstage</p> <p>Crea un comando <code>unstage</code> para descartar cambios de archivo <pre><code>git config --global alias.unstage 'reset  HEAD --'\n</code></pre> Ahora estas dos instrucciones son equivalentes: <pre><code>git unstage &lt;archivo&gt;\ngit reset HEAD &lt;archivo&gt;\n</code></pre></p> <p>Comando tree</p> <p>Crea un comando'tree' para visualizar los commits, tags y ubicacion del HEAD de forma resumida: <pre><code># Recomendado: crear comando 'tree'\ngit config --global alias.tree \"log --graph --decorate --all --oneline\" \n</code></pre></p>","tags":["Git","GitHub"]},{"location":"git/bifurcaciones/","title":"Bifurcaciones","text":"<p>Git permite gestionar m\u00faltiples ramas o bifurcaciones (branches) en un mismo proyecto, lo cual permite amntener versiones alternativas de un mismo proyecto, implementar correcciones y mejoras en paralelo a la rama en producci\u00f3n, etc.</p>","tags":["Git"]},{"location":"git/bifurcaciones/#informacion-de-ramas-branch","title":"Informacion de ramas - <code>branch</code>","text":"<p>Indicar qu\u00e9 ramas del proyecto  hay disponibles y en cu\u00e1l nos encontramos: <pre><code>git branch\n</code></pre></p> <p>Rama principal</p> <p>La rama creada al inicializarse el proyecto suele llamarse <code>master</code> o <code>main</code>, dependiendo de la versi\u00f3n de Git usada.</p>","tags":["Git"]},{"location":"git/bifurcaciones/#crear-ramas","title":"Crear ramas","text":"<p>Para crear una nueva rama en el proyecto:</p> <pre><code>git branch nombre_nueva_rama\n</code></pre>","tags":["Git"]},{"location":"git/bifurcaciones/#cambio-de-rama-actual","title":"Cambio de rama actual","text":"<p>Conmuta a la rama elegida del proyecto:</p> <pre><code>git switch nombre_rama\n</code></pre> <p>Renombrar una rama: <pre><code>git branch -m nombre_rama nuevo_nombre_rama\n</code></pre> Ejemplo:  de master a main  <pre><code>git branch -m master main\n</code></pre></p> <p>Estado y cambio entre ramas</p> <p>Git requiere que todos los cambios hechos sobre los archivos del repositorio est\u00e9n guardados o descartados antes de permitir el cambio de rama.</p> <p>Si hay cambios provisorios se puede recurrir al guardado provisional, con el comando <code>stash</code></p>","tags":["Git"]},{"location":"git/bifurcaciones/#union-de-ramas-merge","title":"Uni\u00f3n de Ramas - <code>merge</code>","text":"<p>Las versiones paralelas del proyecto pueden reunirse para recolectar los cambios realizados entre ellas. <pre><code>git switch nombre_rama_definitiva\n</code></pre></p> <p>Nos ubicamos en la rama que queremos actualizar y mantener. <pre><code>git merge rama_alterna\n</code></pre> Elegimos la rama de la que se leer\u00e1n los cambios a a\u00f1adir. Esta \u00faltima NO dejar\u00e1 de existir sino que seguir\u00e1 igual.</p>","tags":["Git"]},{"location":"git/bifurcaciones/#eliminacion-de-ramas","title":"Eliminaci\u00f3n de ramas","text":"<p>Las ramas locales que ya no sean necesarias se eliminan con la opci\u00f3n <code>-d</code>:</p> Eliminar rama<pre><code>git branch -d  nombre_rama\n</code></pre> <p>Nombres de rama</p> <p>Se puede eliminar y volver a crear una rama con el mismo nombre. </p>","tags":["Git"]},{"location":"git/cambios_registro/","title":"Cambios y registro","text":"","tags":["Git","Bash"]},{"location":"git/cambios_registro/#observar-cambios","title":"Observar cambios","text":"<p>El comando <code>diff</code> indica qu\u00e9 cambios fueron realizados en cada archivo alterado respecto de su \u00faltimo estado agregado (added) o comprometido (commited):  Diferencias - no agregadas<pre><code>git diff\n</code></pre> S\u00f3lo se muestran cambios pendientes de agregar en el repositorio.  Si se busca ver qu\u00e9 cambios ya fueron agregados al repositorio entonces se agrega la opci\u00f3n <code>staged</code>:</p> Diferencias - ya agregadas<pre><code>git diff --staged\n</code></pre> <p>Para ver solamente los cambios en un archivo espec\u00edfico ya trackeado se indica su nombre:</p> Diferencias - por archivo<pre><code>git diff nombre_archivo\n</code></pre> <p>Caracter de escape</p> <p>Se sale del reporte por terminal con la tecla Q.</p>","tags":["Git","Bash"]},{"location":"git/cambios_registro/#registro-de-guardados-log","title":"Registro de guardados - <code>log</code>","text":"<p>El comando <code>log</code> proporciona un historial de los commits realizados:</p> log - completo<pre><code>git log\n</code></pre> <p>donde se muestra una lista en orden de los commit realizados con su n\u00famero de identificador, su descripci\u00f3n realizada, etc. Tambi\u00e9n se agrega informaci\u00f3n del autor de cada commit, su mail, fecha de guardado, etc. Los cambios comprometidos m\u00e1s recientes aparecen primero. </p> <p>Una variante resumida se obtiene agregando la opci\u00f3n <code>--oneline</code>:</p> log - resumido<pre><code>git log --oneline\n</code></pre> <p>donde se omite la informaci\u00f3n del autor y el resultado es algo como esto:</p> <pre><code>4536537 (HEAD -&gt; master, origin/master) Proyecto reorganizado 3\nc0579b8 Proyecto reorganizado 2\n1bdac61 Proyecto reorganizado\n... (commits previos)\n</code></pre> <p>De esta pantalla informativa se sale con la tecla Q.</p> <p>Aparecen indicados varios elementos adicionales:</p> <ul> <li>El apuntador <code>HEAD</code> que indica qu\u00e9 commit  (qu\u00e9 \"versi\u00f3n\") del proyecto es el que Git muestra actualmente; </li> <li>informaci\u00f3n de la ramificaci\u00f3n actual del repositorio;</li> <li>informaci\u00f3n de la version remota del repositorio.</li> </ul> <p>Estos elementos ser\u00e1n explicados m\u00e1s adelante.</p>","tags":["Git","Bash"]},{"location":"git/commits_previos/","title":"Commits previos","text":"<p>El comando 'reset' nos permite cambiar de versi\u00f3n, con tres modalidades: hard, mixed y soft HEAD indica el commit usado en el presente (versi\u00f3n actual del proyecto). 'hard' es una de las variantes del reset, que actualiza todo el proyecto a la versi\u00f3n requerida.</p> <p>Siempre podremos volver al ultimo guardado con el comando reset: <pre><code>git reset   # regreso al \u00faltimo commit realizado\n</code></pre></p> <p>IMPORTANTE: Hay que guardar los \u00faltimos cambios antes para que no se pierdan. Y si los commits a omitir ya est\u00e1n compartidos en un repositorio p\u00fablico pueden producirse errores. Cuidado. <pre><code>git reset --hard HEAD~1\n</code></pre> Retrocedemos al commit inmediatamente anterior.Oculta el commit actual.</p> <p>HINT</p> <p>El car\u00e1cter <code>~</code> se obtiene escribiendo AltGr+4</p> <p><pre><code>git reset --hard HEAD~&lt;n&gt;\n</code></pre> Retrocedemos n posiciones de guardado, ocultando las posiciones posteriores.</p> <p>Oculta los commits posteriores al elegido como destino.</p>","tags":["Git"]},{"location":"git/commits_previos/#navegacion-por-indices","title":"Navegaci\u00f3n por \u00edndices","text":"<p>El comando <code>reflog</code> muestra el historial de commits del repositorio y lo combina con el historial de movimientos.  Adem\u00e1s, a cada estado le asigna un \u00edndice auxiliar que ayuda a navegar entre commits, donde el \u00edndice <code>0</code> corresponde al estado m\u00e1s reciente.</p> <p>Repasa el historial de guardados y movimientos:</p> <p><pre><code>git reflog\n</code></pre> El comando no requiere argumentos adicionales.</p> <p>Para poder \"navegar\" entre estados en base a los \u00edndices de <code>reflog</code>  se usa el comando <code>reset</code> con la opci\u00f3n <code>HEAD@</code>:</p> <pre><code>git reset --hard HEAD@{numero_indice}\n</code></pre> <p>Esto nos mueve al guardado indicado por el n\u00famero de \u00edndice.</p> <p>cambio de \u00edndices</p> <p>Cada vez que se llama al comando <code>reset</code> cambian los \u00edndices dados por <code>reflog</code></p>","tags":["Git"]},{"location":"git/commits_previos/#buscar-commmit-por-id","title":"Buscar commmit por id","text":"<p>El comando <code>checkout</code>permite saltar a un guardado particular en base a su identificador:</p> <pre><code>git checkout id_commit\n</code></pre>","tags":["Git"]},{"location":"git/configuracion_inicial/","title":"Configuracion inicial","text":"","tags":["Git"]},{"location":"git/configuracion_inicial/#configuracion-global","title":"Configuraci\u00f3n global","text":"<p>Git requiere una serie de configuraciones preliminares en la estaci\u00f3n de trabajo para funcionar correctamente.</p>","tags":["Git"]},{"location":"git/configuracion_inicial/#usuario","title":"Usuario","text":"<p>Ponemos nuestro nombre o apodo a nuestra estaci\u00f3n de trabajo: user<pre><code>git config --global user.name nombre_usuario\n</code></pre></p> <p>Tambi\u00e9n declaramos nuestro email: </p> email<pre><code>git config --global user.email   nombre_usuario@servidor_correo\n</code></pre> <p>Este mail es meramente informativo y no se revisa su disponibilidad.</p>","tags":["Git"]},{"location":"git/configuracion_inicial/#editor-por-defecto","title":"Editor por defecto","text":"<p>Se selecciona el editor de texto preferido y la terminal queda en espera hasta que el editor usado se cierre.</p> <pre><code>git config --global core.editor  nombre_editor_texto --wait   \n</code></pre> <p>Ejemplos de editores: </p> Editor Opci\u00f3n VSCode <code>code --wait</code> VSCodium <code>codium --wait</code> Block de Notas <code>notepad --wait</code>","tags":["Git"]},{"location":"git/configuracion_inicial/#fin-de-linea","title":"Fin de l\u00ednea","text":"<p>Configura el salto de l\u00ednea para los archivos seg\u00fan el sistema operativo:</p> WindowsLinux / MAC <pre><code>git config --global core.autocrlf  true\n</code></pre> <pre><code>git config --global core.autocrlf  input\n</code></pre> <p>Esta diferencia responde a que los caracteres ASCII usados para marcar el fin de l\u00ednea no son los mismos para todos los sistemas operativos:</p> Sistema operativo Caracteres de salto l\u00ednea Windows CR LF Linux LF MAC LF <p>Es importante configurar el fin de l\u00ednea para evitar conflictos de seguimiento con otras estaciones de trabajo.</p>","tags":["Git"]},{"location":"git/configuracion_inicial/#archivo-de-configuracion","title":"Archivo de configuraci\u00f3n","text":"<p>El archivo <code>.gitconfig</code> (archivo oculto) guarda todas aquellas configuraciones modificadas por el usuario.</p> <p>Este archivo se abre con el editor predefinido usando el comando: <pre><code>git config --global -e\n</code></pre></p>","tags":["Git"]},{"location":"git/configuracion_inicial/#lista-de-configuraciones","title":"Lista de configuraciones","text":"<p>La lista de configuraciones completa se obtiene con la opci\u00f3n <code>list</code>:</p> <pre><code>git config list\n</code></pre> <p>Regreso a comandos</p> <p>Se puede volver de las ventanas informativas a la ventana de comandos presionando la letra Q.</p>","tags":["Git"]},{"location":"git/gitignore/","title":"Archivo de excepciones","text":"<p>Puede crearse un archivo de excepciones llamado <code>.gitignore</code>,  un archivo oculto donde se indican los archivos y rutas a ignorar por Git.</p>","tags":["Git","Bash"]},{"location":"git/gitignore/#creacion","title":"Creaci\u00f3n","text":"<p>Es posible crear el archivo vac\u00edo desde la terminal:</p> <p>Archivo gitignore - Crear<pre><code>touch .gitignore\n</code></pre> Este archivo va ubicado habitualmente en la ruta ra\u00edz del repositorio,  que es donde se encuentra el directorio <code>.git</code>. De esta forma el archivo afectar\u00e1 a todos los directorios internos.</p>","tags":["Git","Bash"]},{"location":"git/gitignore/#elementos-y-rutas-excluidas","title":"Elementos y rutas excluidas","text":"<p>En el archivo de excepciones se indica rengl\u00f3n a rengl\u00f3n cada archivo y directorio a ignorar por Git. </p> <p>Formato: Archivo gitignore - Excluir elementos<pre><code>nombre_archivo\nnombre_carpeta/\nnombre_carpeta/nombre_subcarpeta/\n</code></pre></p> <p>Si todo sali\u00f3 bien el comando <code>status</code>  dejar\u00e1 de detectar los archivos y carpetas  que fueron listados.</p> <p>Elementos prea\u00f1adidos</p> <p>Debe tenerse en cuenta que si un archivo o directorio fue agregado al repositorio antes de especificarlo en el <code>.gitignore</code> entonces Git lo monitorear\u00e1 de todas maneras. Para solventar este problema el elemento elegido debe ser removido del repositorio con sus comandos espec\u00edficos.</p>","tags":["Git","Bash"]},{"location":"git/gitignore/#extensiones-de-archivo","title":"Extensiones de archivo","text":"<p>Se pueden indicar extensiones de archivo dentro del archivo de excepciones. Por ejemplo, para ignorar archivos de imagen del repositorio:</p> Archivo gitignore - excluir por extensi\u00f3n<pre><code>*.png\n*.jpg\n*.webp\n</code></pre>","tags":["Git","Bash"]},{"location":"git/gitignore/#agregado-al-repositorio","title":"Agregado al repositorio","text":"<p>Se agrega al proyecto el archivo de excepciones:</p> Archivo gitignore - Agregado<pre><code>git add .gitignore\n</code></pre> <p>De esta manera se previene el seguimiento accidental de archivos ajenos temporales, de archivos producidos por el programa del proyecto durante su uso, etc.</p> <p>Si se requiere forzar el agregado de un archivo ya excluido se usa la opci\u00f3n <code>--force</code> \u00f3 <code>-f</code>:</p> <p>M\u00faltiples archivos de excepciones</p> <p>Git permite usar m\u00faltiples archivos <code>.gitignore</code> dentro de un mismo proyecto, repartidos en distintos directorios.  Esto habilita a agregar criterios de exclusi\u00f3n espec\u00edficos para cada directorio del proyecto,  los cuales se superponen a los criterios especificados en el archivo <code>.gitignore</code> principal.</p> <p>Esto habilita usar distintos criterios de exclusi\u00f3n dentro de un mismo proyecto.</p> <p>Variables de Entorno</p> <p>Las variables de entorno (usuarios, contrase\u00f1as, bases de datos etc) NO deben agregarse al repositorio. \u00c9stas suelen guardarse en archivos con extensi\u00f3n <code>.env</code>, por tal motivo es conveniente excluir esta extensi\u00f3n de los repositorios.  Para ello, simplemente agregar al <code>.gitignore</code>:</p> Archivo gitignore - Excluir archivos de entorno<pre><code>*.env\n</code></pre>","tags":["Git","Bash"]},{"location":"git/intro/","title":"Introducci\u00f3n","text":"<p>Git funciona monitoreando los archivos en la carpeta de cada repositorio. Si se detectan cambios en la estructura de archivos o en el contenido de los mismos entonces Git los detecta y permite consolidar los cambios o deshacerlos.</p>","tags":["Git"]},{"location":"git/intro/#etapas","title":"Etapas","text":"<p>Los repositorios de Git trabajan en cuatro grandes etapas:</p>","tags":["Git"]},{"location":"git/intro/#0creacion-untracked","title":"0.Creaci\u00f3n (untracked)","text":"<p>Se crea un nuevo repositorio vac\u00edo con el comando <code>init</code>. En esta primera instancia del repositorio no hay seguimiento de archivos.</p>","tags":["Git"]},{"location":"git/intro/#1cambios-preliminares-stage","title":"1.Cambios preliminares (stage)","text":"<p>Es una etapa intermedia dentro del computador donde el usuario decide qu\u00e9 archivos a\u00f1adir (\u00f3 quitar) y donde se guardan los cambios preliminares realizados sobre los mismos.</p> <p>Utiliza la instrucci\u00f3n <code>add</code> para registrar los cambios en los archivos de inter\u00e9s.</p>","tags":["Git"]},{"location":"git/intro/#2confirmacion-de-cambios-commit","title":"2.Confirmaci\u00f3n de cambios (commit)","text":"<p>Etapa donde se actualizan (guardan) los cambios hechos en los archivos del repositorio y se incorpora la numeraci\u00f3n y una descripci\u00f3n de las modificaciones realizadas. </p> <p>Utiliza la instrucci\u00f3n <code>commit</code> para crear puntos de guardado del repositorio tambi\u00e9n llamados commit.</p>","tags":["Git"]},{"location":"git/intro/#3-sincronizacion-con-servidor-remoto","title":"3. Sincronizaci\u00f3n con servidor remoto","text":"<p>Los repositorios est\u00e1n preparados para ser sincronizados con servidores remotos,  con el fin de trabajar en equipos, compartir los proyectos al p\u00fablico, hacer copias de respaldo, etc.</p> <p>La sincronizaci\u00f3n usa la instrucci\u00f3n <code>push</code> (\"empujar\") para subir los cambios del repositorio local al servidor  y usa <code>pull</code> (\"tirar\") para actualizar los repositorios locales.</p>","tags":["Git"]},{"location":"git/repositorio_remoto/","title":"Repositorio Remoto","text":"","tags":["Git"]},{"location":"git/repositorio_remoto/#configurar-repositorio-remoto","title":"Configurar repositorio remoto","text":"<p>Indicamos la direcci\u00f3n web del servidor y nuestro directorio que aloja el repositorio remoto del proyecto (se presupone que \u00e9ste ya existe): <pre><code>git remote add origin URL/directorio/nombre_proyecto\n</code></pre></p> <p>Ejemplo t\u00edpico : repositorio en GitHub</p> <pre><code>https://github.com/MI_USUARIO/MI_PROYECTO\n</code></pre>","tags":["Git"]},{"location":"git/repositorio_remoto/#crear-rama","title":"Crear rama","text":"<p>Crea en el repositorio remoto la rama indicada y sube los cambios guardados realizados (commits) en el proyecto al servidor:</p> <pre><code>git push -u origin nombre_rama\n</code></pre> <p>Rama principal</p> <p>En el servidor  la rama <code>main</code> o <code>master</code> NO est\u00e1 creada por defecto, por lo que debe crearse: <pre><code>git push -u origin master\n</code></pre> </p>","tags":["Git"]},{"location":"git/repositorio_remoto/#actualizar-repositorio-remoto-push","title":"Actualizar repositorio remoto - <code>push</code>","text":"<p>El comando <code>pull</code> sube los nuevos commits del proyecto al servidor:</p> <p><pre><code>git push\n</code></pre> Este comando s\u00f3lo sube los guardados de la rama actual.</p>","tags":["Git"]},{"location":"git/repositorio_remoto/#actualizacion-de-repositorio-local-pull-y-fetch","title":"Actualizaci\u00f3n de repositorio local - <code>pull</code> y <code>fetch</code>","text":"<p>El comando <code>pull</code> descarga las nuevas versiones desde el repositorio remoto al local: <pre><code>git pull\n</code></pre> A veces es necesario usarlo para  \u201cunir\u201d la rama remota con la actual del proyecto. </p> <p>Similar a <code>pull</code>  pero creando una rama alterna en nuestra estaci\u00f3n de trabajoes el comando <code>fetch</code>:</p> <pre><code>git fetch\n</code></pre>","tags":["Git"]},{"location":"git/repositorio_remoto/#eliminar-ramas","title":"Eliminar ramas","text":"<p>Eliminar la rama remota elegida: <pre><code>git push origin -d  nombre_rama\n</code></pre> Elimina las ramas locales que ya no est\u00e9n en el repositorio remoto: <pre><code>git fetch -p \n</code></pre></p>","tags":["Git"]},{"location":"git/repositorio_remoto/#como-corregir-errores-de-origen","title":"Como corregir errores de origen","text":"<p>Si aparece el error de subida porque \u201c el origen remoto ya existe\u201d podemos escribir:</p> <p>Permite saber a qu\u00e9 URL apunta el puntero origen (origin) <pre><code>git remote -v\n</code></pre></p> <p>Elimina la URL ya cargada para poder empezar de nuevo: <pre><code>git remote remove origin\n</code></pre></p> <p>Asigna una nueva direcci\u00f3n web para reemplazar la antigua. <pre><code>git remote set-url origin &lt;nueva_URL&gt;\n</code></pre></p> <p>Cambia el nombre del puntero origin por uno distinto. <pre><code>git remote rename origin &lt;nuevo_puntero&gt;\n</code></pre></p>","tags":["Git"]},{"location":"git/repositorio_remoto/#clonar-repositorios","title":"Clonar repositorios","text":"<p>El clonado hace una copia completa del proyecto indicado desde el repositorio y la guarda en el directorio actual. Usa el comando <code>clone</code>:</p> <pre><code>git clone &lt;URL_del_proyecto&gt;\n</code></pre> <p>Hay que instalar las dependencias, esto \u00faltimo depende del lenguaje de programaci\u00f3n del proyecto. Cada lenguaje tiene sus propias pr\u00e1cticas y comandos. Recordar que el archivo <code>.gitignore</code> indica qu\u00e9 dependencias ignora GIT en el traspaso de los proyectos.</p> <p>Si no tenemos permitido colaborar con un proyecto ya existente podemos crear un fork en el sitio del repositorio online. As\u00ed tendremos una copia del proyecto original a la cual le podremos hacer los cambios que queramos. Y podemos realizar pull requests (pedidos de modificaci\u00f3n) a los administradores del proyecto original para que puedan agregar nuestros cambios si as\u00ed lo deciden.</p>","tags":["Git"]},{"location":"git/stash/","title":"Guardado provisorio - <code>stash</code>","text":"<p>Git no permite el cambio de rama si los archivos tienen modificaciones no registradas.</p> <p>El comando <code>stash</code> permite hacer guardados temporales  para poder pasar a trabajar en otras ramas del proyecto  sin recurrir a guardados definitivos adicionales con c\u00f3digo defectuoso o incompleto.</p> <p>Guardado temporal: <pre><code>git stash \n</code></pre></p> <p>Para recuperar los cambios provisorios (stash previos): <pre><code>git stash pop\n</code></pre> Listado de guardados temporales en la rama actual: <pre><code>git stash list\n</code></pre> Para ver los 'stash' en todo el proyecto: <pre><code>git status --show-stash\n</code></pre> Descarte de cambios provisorios: <pre><code>git stash clear\n</code></pre></p>","tags":["Git"]},{"location":"git/tags/","title":"Etiquetado","text":"<p>Listar etiquetas de un proyecto:</p> <p><pre><code>git tag\n</code></pre> Listar etiquetas en base a un patr\u00f3n (hay m\u00e1s de 500 en total): <pre><code>git tag -l              #todas las etiquetas realizadas\ngit tag -l patron\n</code></pre> Asignar etiqueta al \u00faltimo commit: <pre><code>git tag etiqueta\n</code></pre> Ejemplo: numeracion para el ultimo <code>commit</code>: <pre><code>git tag v1.0\n</code></pre></p> <p>Asigna un n\u00famero de versi\u00f3n a un <code>commit</code> en base a su nombre <pre><code># REVISAR\ngit tag -a v{numero_version} -m etiqueta\n</code></pre> Asigna un n\u00famero de versi\u00f3n a un commit en base a su nombre.</p> <p>Ejemplos: <pre><code>git tag -a v1.0.0 -m \u201cPrimera versi\u00f3n \u201d\ngit tag -a v1.2.3  codigo_commit\n</code></pre></p> <p>Las etiquetas no se transmiten al repositorio remoto de forma autom\u00e1tica sino que esto debe hacerse manualmente.</p> <p>Para subir una etiqueta al repositorio remoto: <pre><code># etiqueta actual --&gt; remoto\ngit push origin v{numero_version}\n</code></pre> Para subir todas las etiquetas al repositorio remoto: <pre><code># etiquetas (todas) --&gt; remoto\ngit push origin --tags\n</code></pre></p> <p>Las etiquetas nos permiten movernos a un punto de guardado espec\u00edfico. Si queremos movernos a un estado del proyecto indicado por su etiqueta se escribe: <pre><code>git checkout tags/etiqueta\n</code></pre></p> <p>Las etiquetas pueden eliminarse. Para ello hacer: <pre><code># borrado de tags\ngit tag -d etiqueta                  # repositorio local\ngit push --delete origin etiqueta    # repositorio remoto\n</code></pre></p>","tags":["Git"]},{"location":"git/uso_basico/","title":"Uso b\u00e1sico","text":"","tags":["Git","Bash"]},{"location":"git/uso_basico/#inicializacion-init","title":"Inicializaci\u00f3n - <code>init</code>","text":"<p>Este comando crea un repositorio Git en la ubicaci\u00f3n actual: Crear repositorio<pre><code> git init\n</code></pre> creando autom\u00e1ticamente la subcarpeta oculta <code>.git</code> con toda la informaci\u00f3n del repositorio, sus cambios, etc.  Esta carpeta es manejada exclusivamente por Git y no se sube al servidor remoto.</p>","tags":["Git","Bash"]},{"location":"git/uso_basico/#agregado-add","title":"Agregado - <code>add</code>","text":"<p>El comando <code>add</code> a\u00f1ade al repositorio los cambios realizados hasta el momento del archivo especificado \u00fanicamente.</p> Agregado - archivo \u00fanico<pre><code>git add nombre_archivo\n</code></pre> <p>A\u00f1ade al repositorio la carpeta indicada completa:</p> Agregado - carpeta completa<pre><code>git add nombre_directorio\n</code></pre> <p>A\u00f1ade al repositorio las modificaciones de todos los archivos indicados:</p> Agregado - m\u00faltiples archivos<pre><code>git add  nombre_archivo_1  nombre_archivo_2  nombre_archivo_3\n</code></pre> <p>A\u00f1ade al repositorio todos los archivos terminados en la extension indicada: Agregado - archivos por extension<pre><code>git add  *.extension_archivo\n</code></pre> Ejemplo: s\u00f3lo archivos TXT <pre><code>git add *.txt\n</code></pre></p> <p>A\u00f1adido de todos los archivos </p> <p>Es una mala pr\u00e1ctica porque puede a\u00f1adir al proyecto archivos ajenos al programa: binarios, im\u00e1genes de entrada, archivos de salida del programa, etc.</p> <p>Algunas opciones para a\u00f1adir todos los archivos existentes:</p> <pre><code>git add .\ngit add -A\n</code></pre>","tags":["Git","Bash"]},{"location":"git/uso_basico/#estado-del-proyecto-status","title":"Estado del proyecto - <code>status</code>","text":"<p>El comando <code>status</code> da un resumen del proyecto, incluyendo la rama utilizada actualmente por Git, las actualizaciones realizadas del proyecto y archivos incluidos,  distinguiendo:</p> <ul> <li>archivos ya guardados;</li> <li>archivos con cambios pendientes de guardado;</li> <li>archivos no incluidos.</li> </ul> <p>Uso:</p> Estado<pre><code>git status\n</code></pre> <p>Con la opci\u00f3n <code>-s</code> se muestra solamente los archivos del proyecto indicando cuales est\u00e1n alterados y guardados y cu\u00e1les no: Estado (resumido)<pre><code>git status -s\n</code></pre></p>","tags":["Git","Bash"]},{"location":"git/uso_basico/#compromiso-commit","title":"Compromiso - <code>commit</code>","text":"<p>Compromete (guarda) los cambios realizados al proyecto:</p> Compromiso<pre><code>git commit -m \u201cbreve_descripci\u00f3n\u201d\n</code></pre> <p>Este comando crea una especie de punto de guardado con una descripci\u00f3n y un n\u00famero identificador, al cual se puede volver posteriormente.</p> <p>El compromiso siempre va precedido por el comando <code>add</code>,  el cual debe ser usado al menos una vez para registrar alg\u00fan cambio en el proyecto:</p> Compromiso - un archivo<pre><code>git add archivo_modificado\ngit commit -m \u201cbreve_descripci\u00f3n\u201d\n</code></pre> <p>Una alternativa resumida  para comprometer cambios de un \u00fanico archivo es usar directamente las opciones combinada <code>am</code>:</p> Compromiso - \u00fanico archivo del proyecto<pre><code>git commmit -am \u201cbreve_descripci\u00f3n\u201d\n</code></pre> <p>la cual presupone que el archivo ya hab\u00eda sido a\u00f1adido al proyecto previamente.</p>","tags":["Git","Bash"]},{"location":"git/uso_basico/#mover-y-renombrar-archivos","title":"Mover y renombrar archivos","text":"<p>Si un archivo es renombrado o movido de lugar de manera directa entoces Git interpreta que ese archivo fue eliminado  y que otro archivo distinto fue creado, haciendo que el guardado de cambios sea m\u00e1s ineficiente debido a la potencial redundancia de datos dentro del repositorio.</p> <p>Por este motivo es m\u00e1s eficiente usar el comando <code>mv</code> como opci\u00f3n de git:</p> Renombrar archivo<pre><code>git mv nombre_archivo nuevo_nombre\n</code></pre> Mover archivo<pre><code>git mv nombre_archivo ruta_destino/\n</code></pre> <p>De esta forma Git registra que el cambio producido en el proyecto es un simple movimiento de archivo  y puede recrearlo o deshacerlo con una simple oeraci\u00f3n.  Adem\u00e1s el cambio ya queda agregado al proyecto (added).</p>","tags":["Git","Bash"]},{"location":"git/uso_basico/#eliminar-archivos","title":"Eliminar archivos","text":"<p>El comando <code>rm</code> tambi\u00e9n puede ser combinado con <code>git</code>:</p> <p>Eliminar archivo<pre><code>git rm nombre_archivo\n</code></pre> de esta forma la operaci\u00f3n ya queda agregada en el repositorio.</p>","tags":["Git","Bash"]},{"location":"git/uso_basico/#restauracion","title":"Restauraci\u00f3n","text":"<p>Una forma de restaurar el archivo a su \u00faltimo estado, sea \u00e9ste un add o un commit, es mediante el comando <code>restore</code>:</p> <pre><code>git restore nombre_archivo\n</code></pre> <p>Si se necesita anular el \u00faltimo agregado de archivo se agrega la opci\u00f3n <code>staged</code>. <pre><code>git restore  --staged nombre_archivo\n</code></pre></p> <p>Una alternativa es usar el comando <code>reset HEAD</code>:</p> <pre><code>git reset HEAD nombre_archivo\n</code></pre> <p>el cual puede ser usado para anular el agregado de todos los archivos del proyecto:</p> <pre><code>git reset HEAD\n</code></pre>","tags":["Git","Bash"]}]}